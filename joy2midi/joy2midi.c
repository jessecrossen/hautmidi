#include <ctype.h>
#include <fcntl.h>
#include <malloc.h>
#include <math.h>
#include <pthread.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#include <linux/joystick.h>

#include <jack/jack.h>
#include <jack/midiport.h>

// the path and file to read mapping configuration from
char *map_path = NULL;
FILE *map_file = NULL;
// the file to read joystick events from
char *device_path = NULL;
int device_file = 0;
// the amount of output to send to the console
int verbosity = 0;
// the minimum number of milliseconds between events on a button
int debounce = 0;
// the channel to send MIDI messages on
int channel = 0;

// the JACK client we're connected as
jack_client_t *jack_client = NULL;
// the JACK output port for MIDI
jack_port_t *jack_port = NULL;
// a mutex for stopping joystick input during the process call
pthread_mutex_t process_lock;
// the sample rate JACK is using
jack_nframes_t jack_sample_rate;

// a struct for input/output mapping specifiers
typedef struct {
  int type;
  int number;
  int min;
  int max;
} MapSpec;
// an entry in a linked list of mappings
typedef struct {
  MapSpec inspec;
  MapSpec outspec;
  void *next;
} Mapping;
// the ends of the linked list of mappings
Mapping *map_head = NULL;
Mapping *map_tail = NULL;

// a struct to store events from the joystick
typedef struct js_event JoystickEvent;
// a struct to store outgoing MIDI events
typedef struct {
  // the time of the event within the frame in microseconds
  long time;
  // event data
  uint8_t data[3];
  // a pointer to construct a linked list
  void *next;
} MidiMessage;
// the ends of the linked list of messages
MidiMessage *messages_head = NULL;
MidiMessage *messages_tail = NULL;

// forward declarations for the main program functions
void add_mapping(MapSpec, MapSpec);
MidiMessage *joystick_event_to_midi_message(JoystickEvent);
void send_midi_message(MidiMessage *message);
static int jack_process(jack_nframes_t, void *);

// map file parser (generated by Bison)
#include "parser.tab.c"

int main(int argc, char **argv) {
  int result;
  // the most recent joystick event received from the device
  JoystickEvent event;
  // the next message to send to MIDI output
  MidiMessage *message = NULL;
  
  // check arguments
  if (argc != 3) {
    printf("\n"
    "Usage: joy2midi <map-file> <device>\n"
    "\n");
    return(1);
  }
  
  // open and parse the map file
  map_path = argv[argc - 2];
  map_file = fopen(map_path, "rb");
  if (map_file == NULL) { fprintf(stderr, 
    "ERROR: Failed to open map file at '%s' for reading.\n", map_path);
    return(1);
  }
  parse_map();
  fclose(map_file);
  
  // open the device file
  device_path = argv[argc - 1];
  device_file = open(device_path, O_RDONLY);
  if (! device_file) { fprintf(stderr, 
    "ERROR: Failed to open device at '%s' for reading.\n", device_path);
    return(1);
  }
  
  // connect to JACK
  jack_status_t jack_status;
  jack_client = jack_client_open("joy2midi", JackNoStartServer, &jack_status);
  if ((jack_status & JackServerFailed) != 0) { fprintf(stderr, 
    "ERROR: Failed to connect to the JACK server.\n");
    return(1);
  }
  else if ((jack_status & JackServerError) != 0) { fprintf(stderr, 
    "ERROR: Failed to communicate with the JACK server.\n");
    return(1);
  }
  else if ((jack_status & JackFailure) != 0) { fprintf(stderr, 
    "ERROR: Failed to create a JACK client.\n");
    return(1);
  }
  // create a port for MIDI output
  jack_port = jack_port_register(jack_client, "out", 
    JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput | JackPortIsTerminal, 0);
  if (jack_port == NULL) { fprintf(stderr, 
    "ERROR: Failed to create a JACK output port.\n");
    return(1);
  }
  // activate the client for sending MIDI
  result = jack_set_process_callback(jack_client, jack_process, NULL);
  if (result != 0) { fprintf(stderr, 
    "ERROR: Failed to bind a JACK processing callback (error %i).\n", result);
    return(1);
  }
  result = jack_activate(jack_client);
  if (result != 0) { fprintf(stderr, 
    "ERROR: Failed to activate JACK client (error %i).\n", result);
    return(1);
  }
  // get the sample rate to convert times
  jack_sample_rate = jack_get_sample_rate(jack_client);
  
  // read and translate joystick events
	while (1) {
		if (read(device_file, &event, sizeof(JoystickEvent)) != sizeof(JoystickEvent)) {
			fprintf(stderr, "ERROR: Failed to read from joystick device.\n");
			return(1);
		}
		message = joystick_event_to_midi_message(event);
		if (message != NULL) send_midi_message(message);
	}

}

// MAPPINGS *******************************************************************

// add a mapping to the linked list
void add_mapping(MapSpec inspec, MapSpec outspec) {
  // make a new mapping entry
  Mapping *entry = (Mapping *)malloc(sizeof(Mapping));
  if (entry == NULL) {
    fprintf(stderr, "ERROR: Error allocating memory for mapping.\n");
    return;
  }
  // initialize the mapping
  entry->inspec = inspec;
  entry->outspec = outspec;
  entry->next = NULL;
  // begin the list if there isn't one
  if (map_head == NULL) {
    map_head = entry;
    map_tail = entry;
  }
  // otherwise extend the list
  else {
    map_tail->next = entry;
    map_tail = entry;
  }
}

// JOYSTICK => MIDI TRANSLATION ***********************************************

// fill in the data for a MIDI message
MidiMessage *make_midi_message(int type, int number, int value) {
  // allocate a message
  MidiMessage *message = (MidiMessage *)malloc(sizeof(MidiMessage));
  if (message == NULL) return(NULL);
  message->next = NULL;
  // clamp parameters
  if (value < 0) value = 0;
  if (number < 0) number = 0;
  if (number > 127) number = 127;
  // map to a MIDI message
  if (type == NOTE) {
    if (value > 127) value = 127;
    if (value > 0) message->data[0] = 0x90; // note on
    else           message->data[0] = 0x80; // note off
    message->data[1] = number;              // note number
    message->data[2] = value;               // velocity
  }
  else if (type == CONTROL) {
    if (value > 127) value = 127;
    message->data[0] = 0xB0;                // control change
    message->data[1] = number;              // control number
    message->data[2] = value;               // control value
  }
  else if (type == BEND) {
    if (value > 0x3FFF) value = 0x3FFF;
    message->data[0] = 0xE0;                // pitch bend
    message->data[1] = value & 0x7F;        // bend amount LSB (7 bits)
    message->data[2] = (value >> 7) & 0x7F; // bend amount MSB (7 bits)
  }
  // add the channel to send on
  message->data[0] |= channel;
  return(message);
}

// filter messages that don't change the state
MidiMessage *dedup_filter(MidiMessage *message) {
  static int notes[128];
  static int controls[128];
  static int bend = 0;
  // allow safe chaining of filters
  if (message == NULL) return(NULL);
  // keep the message by default
  int keep = 1;
  // remove channel information for easy comparison
  int type = message->data[0] & 0xF0;
  int number = message->data[1] & 0x7F;
  int value = message->data[2] & 0x7F;
  // note on
  if (type == 0x90) {
    if (notes[number] == 1) keep = 0;
    else notes[number] = 1;
  }
  // note off
  else if (type == 0x80) {
    if (notes[number] == 0) keep = 0;
    else notes[number] = 0;
  }
  // control change
  else if (type == 0xB0) {
    if (controls[number] == value) keep = 0;
    else controls[number] = value;
  }
  // pitch bend
  else if (type == 0xE0) {
    value = (value << 7) | number;
    if (bend == value) keep = 0;
    else bend = value;
  }
  // keep or discard the message
  if (keep) {
    return(message);
  }
  else {
    free(message);
    return(NULL);
  }
}

// filter messages that come too soon after the last of of that type
MidiMessage *debounce_filter(MidiMessage *message) {
  static jack_nframes_t note_times[128];
  // allow safe chaining of filters
  if (message == NULL) return(NULL);
  // keep the message by default
  int keep = 1;
  // remove channel information for easy comparison
  int type = message->data[0] & 0xF0;
  int number = message->data[1] & 0x7F;
  // restrict the minimum interval between note on events for the same note
  if (type == 0x90) {
    // get the current time
    jack_nframes_t now = jack_frame_time(jack_client);
    if (note_times[number] > 0) {
      // get the interval in milliseconds
      int interval = ((now - note_times[number]) * 1000) / jack_sample_rate;
      if (interval < debounce) keep = 0;
    }
    if (keep != 0) note_times[number] = now;
  } 
  // keep or discard the message
  if (keep) {
    return(message);
  }
  else {
    free(message);
    return(NULL);
  }
}

// map a joystick event to a MIDI message
MidiMessage *joystick_event_to_midi_message(JoystickEvent event) {
  int range;
  float value;
  // get the mapspec type to search for
  int type;
  if (event.type == JS_EVENT_BUTTON) type = BUTTON;
  else if (event.type == JS_EVENT_AXIS) type = AXIS;
  // skip events we don't use
  else return(NULL);
  // search mappings
  Mapping *mapping = NULL;
  for (mapping = map_head; mapping != NULL; mapping = mapping->next) {
    // filter events
    if (type != mapping->inspec.type) continue;
    if (event.number != mapping->inspec.number) continue;
    if (event.value < mapping->inspec.min) continue;
    if (event.value > mapping->inspec.max) continue;
    // if we're ignoring this input, we're done
    if (mapping->outspec.type == IGNORE) return(NULL);
    // map the value onto the range 0.0 to 1.0 so we can transform 
    //  to the output range
    range = mapping->inspec.max - mapping->inspec.min;
    if (range > 0) 
      value = (float)(event.value - mapping->inspec.min) / (float)range;
    else 
      value = 1.0;
    // map to the output range
    range = mapping->outspec.max - mapping->outspec.min;
    value = (float)mapping->outspec.min + ((value * (float)range));
    // fill in the data of the midi message
    MidiMessage *message = make_midi_message(
      mapping->outspec.type, mapping->outspec.number, (int)round(value));
    // filter redundant messages
    message = debounce_filter(message);
    message = dedup_filter(message);
    return(message);
  }
  // report on unhandled events
  if (verbosity >= 2) {
    if (event.type == JS_EVENT_BUTTON) {
      printf("Unmapped joystick button %d: %d\n", event.number, event.value);
    }
    else if (event.type == JS_EVENT_AXIS) {
      printf("Unmapped joystick axis %d: %d\n", event.number, event.value);
    }
  }
  return(NULL);
}

// MIDI OUTPUT ****************************************************************

void send_midi_message(MidiMessage *message) {
  // obtain a lock so we don't interfere with JACK processing
  pthread_mutex_t *lock = &(process_lock);
  pthread_mutex_lock(lock);
    // get the time of the message within the current processing block
    message->time = 
      jack_frame_time(jack_client) - jack_last_frame_time(jack_client);
    // queue messages for sending
    if (messages_tail == NULL) {
      messages_head = messages_tail = message;
    }
    else {
      messages_tail->next = (void *)message;
      messages_tail = message;
    }
    if (verbosity >= 3) {
	    printf("send: %02X %02X %02X\n", 
	      message->data[0], message->data[1], message->data[2]);
	  }
	pthread_mutex_unlock(lock);
}

static int jack_process(jack_nframes_t nframes, void *context) {
  unsigned char *midi_buffer;
  // get a writable buffer for the port and clear it for writing
  void *port_buffer = jack_port_get_buffer(jack_port, nframes);
  if (port_buffer == NULL) return(0);
  jack_midi_clear_buffer(port_buffer);
  // if the queue is empty we don't need to process anything
  if (messages_head == NULL) return(0);
  // obtain a lock so nothing changes the send queue while we're sending it
  pthread_mutex_t *lock = &(process_lock);
  pthread_mutex_lock(lock);
    // initialize time counters
    jack_nframes_t last_message_time = 0;
    jack_nframes_t time = 0;
    // dequeue messages
    MidiMessage *message = NULL;
    for (message = messages_head; message != NULL; 
           message = (MidiMessage *)message->next) {
      // make sure messages are sequential with only one per frame
      time = message->time;
      if (time < 0) time = 0;
      if (time >= nframes) time = nframes - 1;
      if (time <= last_message_time) time = last_message_time + 1;
      // send and free the message
      midi_buffer = jack_midi_event_reserve(port_buffer, time, 3);
      if (midi_buffer != NULL) memcpy(midi_buffer, message->data, 3);
      free(message);
      // store the message time for the next go
      last_message_time = time;
    }
    // clear the queue
    messages_head = NULL;
    messages_tail = NULL;
  pthread_mutex_unlock(lock);
  return(0);
}

